<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Bow</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Bow is a library for Typed Functional Programming in Swift">
    <meta name="keywords" content="functional-programming, swift-library, monads, monad-transformers, functional-data-structure, swift, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory">

    <meta property="og:image" content="" />
    <meta property="og:title" content="Bow" />
    <meta property="og:site_name" content="Bow" />
    <meta property="og:url" content="https://bow-swift.io" />
    <meta property="og:type" content="website" />
    <meta property="og:description" content="Bow is a library for Typed Functional Programming in Swift" />
    <meta property="og:keywords" content="functional-programming, swift-library, monads, monad-transformers, functional-data-structure, swift, fp-types, adt, free-monads, tagless-final, mtl, for-comprehension, category-theory" />

    <meta name="twitter:text:description" content="Bow is a library for Typed Functional Programming in Swift" />
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@bow_swift">
    <meta name="twitter:creator" content="@bow_swift">
    <meta name="twitter:image" content="https://bow-swift.io/img/twitter-card.png" />

    <!-- Bow version metadata -->
    
    <meta name="bow-version" data-title="next" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>

    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.6.3/css/all.css" integrity="sha384-UHRtZLI+pbxtHCWp1t77Bi1L4ZtiqrqD80Kn4Z8NTSRyMA2Fd33n5dQ8lWUE00s/" crossorigin="anonymous">

    <!-- Favicon -->
    <link rel="shortcut icon" href="/next/img/favicon.png">
    <!-- Main css -->
    <link rel="stylesheet" type="text/css" href="/next/css/docs.css">
    <!-- Highlighting css -->
    <link rel="stylesheet" type="text/css" href="/next/api-docs/css/highlight.css">

    <!-- Code to manage version information -->
    <script src="/next/js/doc-versions.js" defer></script>

    
        <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=UA-18433785-19"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'UA-18433785-19');
</script>

    

</head>

<body id="doc-body">
<div id="wrapper">
    <div id="sidebar-wrapper">
    <div class="sidebar-brand">
        <a class="brand" href="/next/">
            <img src="/next/img/icon.svg" alt="Bow logo">
            <span>Bow</span>
        </a>
        <button type="button" id="main-toggle" class="sidebar-toggle">
            <span class="close"></span>
        </button>
    </div>

    <div id="version-dropdown">

    <button class="button link-like" onclick="displayToggle(event)" title="Documentation">
      <span>Bow version</span>
      <span id="bow-version">
        
        next
      </span>
    </button>

    <ul class="dropdown dropdown-content">

      <li class="dropdown-item">
        <a class="dropdown-item-link" href="/docs">
            <span>
              0.7.0
            </span>
        </a>
      </li>

      
      <li class="dropdown-item">
        <a class="dropdown-item-link" href="/next/docs">
            <span>
              next
            </span>
        </a>
      </li>
      
    </ul>
</div>


    <ul class="sidebar-nav">
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Quick start</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/quick-start/getting-started/">
                        <i class="fa fa-circle"></i>
                        <span>Getting started</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/quick-start/modules/">
                        <i class="fa fa-circle"></i>
                        <span>Modules</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/quick-start/resources/">
                        <i class="fa fa-circle"></i>
                        <span>Resources</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>FP concepts</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/fp-concepts/glossary/">
                        <i class="fa fa-circle"></i>
                        <span>Glossary</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/functions-vs-procedures/">
                        <i class="fa fa-circle"></i>
                        <span>Functions vs Procedures</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/higher-kinded-types/">
                        <i class="fa fa-circle"></i>
                        <span>Higher Kinded Types</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/type-classes/">
                        <i class="fa fa-circle"></i>
                        <span>Type classes</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/fp-concepts/data-types/">
                        <i class="fa fa-circle"></i>
                        <span>Data types</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Composition</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/composition/overview/">
                        <i class="fa fa-circle"></i>
                        <span>Overview</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/composing-functions/">
                        <i class="fa fa-circle"></i>
                        <span>Composing functions</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/combining-values-of-the-same-type/">
                        <i class="fa fa-circle"></i>
                        <span>Combining values of the same type</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/transforming-data/">
                        <i class="fa fa-circle"></i>
                        <span>Transforming data</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/lifting-values-to-an-effect/">
                        <i class="fa fa-circle"></i>
                        <span>Lifting values to an effect</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/combining-independent-computations/">
                        <i class="fa fa-circle"></i>
                        <span>Combining independent computations</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/sequencing-dependent-computations/">
                        <i class="fa fa-circle"></i>
                        <span>Sequencing dependent computations</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/composition/transforming-multiple-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Transforming multiple effects</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Patterns</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/patterns/error-handling/">
                        <i class="fa fa-circle"></i>
                        <span>Error handling</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/monad-comprehensions/">
                        <i class="fa fa-circle"></i>
                        <span>Monad comprehensions</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/tail-recursion/">
                        <i class="fa fa-circle"></i>
                        <span>Tail recursion</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/state-based-computations/">
                        <i class="fa fa-circle"></i>
                        <span>State-based computations</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/dependency-injection/">
                        <i class="fa fa-circle"></i>
                        <span>Dependency injection</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/patterns/polymorphic-programs/">
                        <i class="fa fa-circle"></i>
                        <span>Polymorphic programs</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Optics</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/optics/overview/">
                        <i class="fa fa-circle"></i>
                        <span>Overview</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/optics/writing-your-own-optics/">
                        <i class="fa fa-circle"></i>
                        <span>Writing your own optics</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/optics/automatic-derivation/">
                        <i class="fa fa-circle"></i>
                        <span>Automatic derivation</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/optics/composition/">
                        <i class="fa fa-circle"></i>
                        <span>Composition</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Effects</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/effects/overview/">
                        <i class="fa fa-circle"></i>
                        <span>Overview</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/suspending-side-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Suspending side effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/manipulating-side-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Manipulating side effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/handling-errors/">
                        <i class="fa fa-circle"></i>
                        <span>Handling errors</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/concurrency/">
                        <i class="fa fa-circle"></i>
                        <span>Concurrency</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/running-side-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Running side effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/retrying-and-repeating-effects/">
                        <i class="fa fa-circle"></i>
                        <span>Retrying and repeating effects</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/handling-resources/">
                        <i class="fa fa-circle"></i>
                        <span>Handling resources</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/effects/foundation-extensions/">
                        <i class="fa fa-circle"></i>
                        <span>Foundation extensions</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Integrations</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/integrations/rxswift-streams/">
                        <i class="fa fa-circle"></i>
                        <span>RxSwift streams</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
        <li class="sidebar-nav-item">
            <a href="#">
                <span>Legal</span>
                
                <i class="fa fa-angle-right"></i>
                
            </a>
            
            <ul>
                
                <li>
                    <a href="/next/docs/legal/credits/">
                        <i class="fa fa-circle"></i>
                        <span>Credits</span>
                    </a>
                </li>
                
                <li>
                    <a href="/next/docs/legal/license/">
                        <i class="fa fa-circle"></i>
                        <span>License</span>
                    </a>
                </li>
                
            </ul>
            
        </li>
        
    </ul>
</div>

    <div id="doc-wrapper">
    <div class="doc-header">
        <button type="button" id="main-toggle" class="sidebar-toggle">
            <i class="fa fa-lg fa-bars menu-icon"></i>
        </button>
    </div>
    <div class="doc-content">
        <h1 id="state-based-computations">State-based computations</h1>

<p class="beginner">beginner</p>

<p>Oftentimes, our programs need to be stateful; that is, we need to maintain an state, perform operations that depend on such state, and even change it as a result of some operations. It usually results in code similar to this:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">var</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">ProgramState</span>
    
<span class="kd">func</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">Output</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Output</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
    <span class="n">state</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">result</span>
<span class="p">}</span>
</code></pre></div></div>

<p>However, this code has some problems:</p>

<ul>
  <li>
    <p>It is using a hidden argument; it uses <code class="highlighter-rouge">state</code> under the hood, which makes the function impure, as the function <code class="highlighter-rouge">operation</code> may return different outputs for the same input.</p>
  </li>
  <li>
    <p>It mutates state, which is a side effect other than computing the result of the function.</p>
  </li>
  <li>
    <p>It is difficult to test the function, as we may not be able to easily set the initial state or check its value after the function execution.</p>
  </li>
</ul>

<h2 id="explicit-parameters-and-return-types">Explicit parameters and return types</h2>

<p>The straightforward solution to this problem is to make everything explicit: the function receives the state as a parameter, and returns it when it is mutated.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">ProgramState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Output</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
    <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The problems mentioned before just disappear as things become explicit. With this version, no side effects are happening when the function is called, and its output only depend on the input. It is easy to test: we can pass the initial state as an argument to the function, and we can assert over the output.</p>

<p>However, it has a new, different problem. Its ergonomics are not very flexible. If we need to perform multiple state-based operations, we need to wire the state manually:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">ProgramState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Intermediate</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Intermediate</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
    <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
    
<span class="kd">func</span> <span class="nf">operation2</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Intermediate</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">ProgramState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Output</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
    <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
<span class="p">}</span>
    
<span class="kd">func</span> <span class="nf">program</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="kt">ProgramState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="nv">state2</span><span class="p">,</span> <span class="nv">intermediate</span><span class="p">)</span> <span class="o">=</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
    <span class="k">return</span> <span class="nf">operation2</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">intermediate</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state2</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the function <code class="highlighter-rouge">program</code> above, we need to get the state from the first <code class="highlighter-rouge">operation</code> and wire it to the <code class="highlighter-rouge">operation2</code>, as the state may have changed. If multiple operations are chained, this option becomes harder to apply.</p>

<h2 id="towards-the-state-type">Towards the State type</h2>

<p>The problem mentioned above can be mitigated by using the State type, provided in Bow. The functions above can be curried, separating the inputs they need to perform their job, from the state they are based on.</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Output</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And finally, wrap the returning function <code class="highlighter-rouge">(ProgramState) -&gt; (ProgramState, Output)</code> into <code class="highlighter-rouge">State&lt;ProgramState, Output&gt;</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Output</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With this change we achieved better ergonomics, as the state wiring now happens by using the <code class="highlighter-rouge">flatMap</code> operation:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Intermediate</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Intermediate</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Intermediate</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Intermediate</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">static</span> <span class="kd">func</span> <span class="nf">operation2</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Intermediate</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">state</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">let</span> <span class="nv">result</span><span class="p">:</span> <span class="kt">Output</span> <span class="o">=</span> <span class="nf">doSomething</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">,</span> <span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">)</span>
        <span class="k">let</span> <span class="nv">newState</span> <span class="o">=</span> <span class="nf">update</span><span class="p">(</span><span class="nv">state</span><span class="p">:</span> <span class="n">state</span><span class="p">,</span> <span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span>
        <span class="nf">return</span> <span class="p">(</span><span class="n">newState</span><span class="p">,</span> <span class="n">result</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
    
<span class="kd">static</span> <span class="kd">func</span> <span class="nf">program</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">)</span><span class="o">.</span><span class="n">flatMap</span> <span class="p">{</span> <span class="n">intermediate</span> <span class="k">in</span>
        <span class="nf">operation2</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">intermediate</span><span class="p">)</span>
    <span class="p">}</span><span class="o">^</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Or we can use Monad comprehensions to obtain an imperative-like syntax:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">static</span> <span class="kd">func</span> <span class="nf">program2</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="kt">Input</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">intermediate</span> <span class="o">=</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Intermediate</span><span class="o">&gt;.</span><span class="k">var</span><span class="p">()</span>
    <span class="k">let</span> <span class="nv">output</span> <span class="o">=</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">ProgramState</span><span class="p">,</span> <span class="kt">Output</span><span class="o">&gt;.</span><span class="k">var</span><span class="p">()</span>
    
    <span class="k">return</span> <span class="nf">binding</span><span class="p">(</span>
        <span class="n">intermediate</span> <span class="o">&lt;-</span> <span class="nf">operation</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">input</span><span class="p">),</span>
        <span class="n">output</span> <span class="o">&lt;-</span> <span class="nf">operation2</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">intermediate</span><span class="o">.</span><span class="k">get</span><span class="p">),</span>
        <span class="nv">yield</span><span class="p">:</span> <span class="n">output</span><span class="o">.</span><span class="k">get</span><span class="p">)</span><span class="o">^</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Invoking <code class="highlighter-rouge">program</code> or <code class="highlighter-rouge">program2</code> will provide a description of the program, but it is not yet executed, as we need to provide an initial state. We can do it with the following functions:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">description</span> <span class="o">=</span> <span class="nf">program</span><span class="p">(</span><span class="nv">input</span><span class="p">:</span> <span class="n">myInput</span><span class="p">)</span>

<span class="c1">// Provides both state and output</span>
<span class="k">let</span> <span class="p">(</span><span class="nv">finalState</span><span class="p">,</span> <span class="nv">finalOutput</span><span class="p">)</span> <span class="o">=</span> <span class="n">description</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">initialState</span><span class="p">)</span>

<span class="c1">// Provides only the output</span>
<span class="k">let</span> <span class="nv">finalOutput2</span> <span class="o">=</span> <span class="n">description</span><span class="o">.</span><span class="nf">runA</span><span class="p">(</span><span class="n">initialState</span><span class="p">)</span>
    
<span class="c1">// Provides only the state</span>
<span class="k">let</span> <span class="nv">finalState2</span> <span class="o">=</span> <span class="n">description</span><span class="o">.</span><span class="nf">runS</span><span class="p">(</span><span class="n">initialState</span><span class="p">)</span>
</code></pre></div></div>

<h2 id="an-applied-example">An applied example</h2>

<p>Let’s apply this to an example, taken from <em>The Craft of Functional Programming</em>, by Simon Thompson. The problem asks us to transform a tree of arbitrary values into a tree of integers, where nodes are tagged with the same integer value if they contained the same value in the original tree, starting with 0.</p>

<p>That is, we can visit a node; if its content has been seen before, we tag it with the corresponding value; otherwise, we assign it a new tag and increment the next tag.</p>

<p>We can model a binary tree as:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">enum</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">case</span> <span class="nf">leaf</span><span class="p">(</span><span class="kt">A</span><span class="p">)</span>
    <span class="kd">indirect</span> <span class="k">case</span> <span class="nf">node</span><span class="p">(</span><span class="kt">A</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next step is to model our state. We can have a table of the visited nodes, together with their integer task using a Swift Dictionary, and the value for the next tag. This entails the values saved in the original tree need to conform to <code class="highlighter-rouge">Hashable</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">struct</span> <span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">:</span> <span class="kt">Hashable</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="nv">tags</span><span class="p">:</span> <span class="p">[</span><span class="kt">A</span><span class="p">:</span> <span class="kt">Int</span><span class="p">]</span>
    <span class="k">let</span> <span class="nv">nextTag</span><span class="p">:</span> <span class="kt">Int</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each time we visit a node or a leaf, we will need to process its value. We will have to get a tag for the value if it has been previously seen, or get a new one, save it into the state and increment the next tag. Therefore, the processing function will take values of an arbitrary type, return values of type <code class="highlighter-rouge">Int</code>, and do work based on an state of type <code class="highlighter-rouge">Table&lt;A&gt;</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">process</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">:</span> <span class="kt">Hashable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="kt">A</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="kt">State</span> <span class="p">{</span> <span class="n">table</span> <span class="o">-&gt;</span> <span class="p">(</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Int</span><span class="p">)</span> <span class="k">in</span>
        <span class="k">if</span> <span class="k">let</span> <span class="nv">tag</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">tags</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="p">{</span>
            <span class="nf">return</span> <span class="p">(</span><span class="n">table</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="k">let</span> <span class="nv">tag</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">nextTag</span>
            <span class="k">var</span> <span class="nv">newTags</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">tags</span>
            <span class="n">newTags</span><span class="p">[</span><span class="n">value</span><span class="p">]</span> <span class="o">=</span> <span class="n">tag</span>
            <span class="k">let</span> <span class="nv">newNextTag</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">nextTag</span> <span class="o">+</span> <span class="mi">1</span>
            <span class="k">let</span> <span class="nv">newTable</span> <span class="o">=</span> <span class="kt">Table</span><span class="p">(</span><span class="nv">tags</span><span class="p">:</span> <span class="n">newTags</span><span class="p">,</span> <span class="nv">nextTag</span><span class="p">:</span> <span class="n">newNextTag</span><span class="p">)</span>
            <span class="nf">return</span> <span class="p">(</span><span class="n">newTable</span><span class="p">,</span> <span class="n">tag</span><span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, our state base function needs to receive a tree, visit each of its nodes and produce a tree of integers, depending on an state of type <code class="highlighter-rouge">Table&lt;A&gt;</code>:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">number</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">:</span> <span class="kt">Hashable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">tree</span> <span class="p">{</span>
    <span class="c1">// If it is a leaf, we process its value and put it back into a tree leaf.</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">process</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Tree</span><span class="o">.</span><span class="n">leaf</span><span class="p">)</span><span class="o">^</span>
    
    <span class="c1">// If it is a node, we need to process the value, and the left</span>
    <span class="c1">// and right parts of the tree, and then assemble them back</span>
    <span class="c1">// into a tree again:</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">leftTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">rightTree</span><span class="p">):</span>
        <span class="k">let</span> <span class="nv">tag</span>       <span class="o">=</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Int</span><span class="o">&gt;.</span><span class="k">var</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">leftTags</span>  <span class="o">=</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;&gt;.</span><span class="k">var</span><span class="p">()</span>
        <span class="k">let</span> <span class="nv">rightTags</span> <span class="o">=</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;&gt;.</span><span class="k">var</span><span class="p">()</span>
        
        <span class="k">return</span> <span class="nf">binding</span><span class="p">(</span>
            <span class="n">tag</span>       <span class="o">&lt;-</span> <span class="nf">process</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">),</span>
            <span class="n">leftTags</span>  <span class="o">&lt;-</span> <span class="nf">number</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">leftTree</span><span class="p">),</span>
            <span class="n">rightTags</span> <span class="o">&lt;-</span> <span class="nf">number</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">rightTree</span><span class="p">),</span>
            
            <span class="nv">yield</span><span class="p">:</span> <span class="kt">Tree</span><span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="n">tag</span><span class="o">.</span><span class="k">get</span><span class="p">,</span>
                             <span class="nv">left</span><span class="p">:</span> <span class="n">leftTags</span><span class="o">.</span><span class="k">get</span><span class="p">,</span>
                             <span class="nv">right</span><span class="p">:</span> <span class="n">rightTags</span><span class="o">.</span><span class="k">get</span><span class="p">))</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can now create a sample tree to run our program with:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 The following code represents this tree:
 B
 |- A
 |  |- C
 |  \- B
 |
 \- C
    |- D
    |  |- B
    |  \- A
    |
    \- E
 */</span>
<span class="k">let</span> <span class="nv">sampleTree</span><span class="p">:</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span> <span class="o">=</span>
    <span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="s">"B"</span><span class="p">,</span>
          <span class="nv">left</span><span class="p">:</span> <span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="s">"A"</span><span class="p">,</span>
                      <span class="nv">left</span><span class="p">:</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="s">"C"</span><span class="p">),</span>
                      <span class="nv">right</span><span class="p">:</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="s">"B"</span><span class="p">)),</span>
          <span class="nv">right</span><span class="p">:</span> <span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="s">"C"</span><span class="p">,</span>
                       <span class="nv">left</span><span class="p">:</span> <span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="s">"D"</span><span class="p">,</span>
                                   <span class="nv">left</span><span class="p">:</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="s">"B"</span><span class="p">),</span>
                                   <span class="nv">right</span><span class="p">:</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="s">"A"</span><span class="p">)),</span>
                       <span class="nv">right</span><span class="p">:</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="s">"E"</span><span class="p">)))</span>
</code></pre></div></div>

<p>Our initial state starts with an empty dictionary and 0 as the next tag:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="nv">initialState</span> <span class="o">=</span> <span class="kt">Table</span><span class="o">&lt;</span><span class="kt">String</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">tags</span><span class="p">:</span> <span class="p">[:],</span> <span class="nv">nextTag</span><span class="p">:</span> <span class="mi">0</span><span class="p">)</span>
</code></pre></div></div>

<p>Then, we can obtain the numbered tree by passing our sample tree to the function, and then running it with the initial state:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">let</span> <span class="p">(</span><span class="nv">finalState</span><span class="p">,</span> <span class="nv">numberedTree</span><span class="p">)</span> <span class="o">=</span> <span class="nf">number</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">sampleTree</span><span class="p">)</span><span class="o">.</span><span class="nf">run</span><span class="p">(</span><span class="n">initialState</span><span class="p">)</span>

<span class="cm">/*
The numberedTree is:
0
|- 1
|  |- 2
|  \- 0
|
\- 2
   |- 3
   |  |- 0
   |  \- 1
   |
   \- 4
*/</span>
</code></pre></div></div>

<p>An alternative, but equivalent, way of building the numbering function would be using the <code class="highlighter-rouge">zip</code> function, as processing the value and the children trees of a node are independent operations:</p>

<div class="language-swift highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">func</span> <span class="n">number_v2</span><span class="o">&lt;</span><span class="kt">A</span><span class="p">:</span> <span class="kt">Hashable</span><span class="o">&gt;</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">State</span><span class="o">&lt;</span><span class="kt">Table</span><span class="o">&lt;</span><span class="kt">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">Tree</span><span class="o">&lt;</span><span class="kt">Int</span><span class="o">&gt;&gt;</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="n">tree</span> <span class="p">{</span>
    <span class="c1">// If it is a leaf, we process its value and put it back into a tree leaf.</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">leaf</span><span class="p">(</span><span class="n">value</span><span class="p">):</span>
        <span class="k">return</span> <span class="nf">process</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">)</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Tree</span><span class="o">.</span><span class="n">leaf</span><span class="p">)</span><span class="o">^</span>
    
    <span class="c1">// If it is a node, we need to process the value, and the left</span>
    <span class="c1">// and right parts of the tree, and then assemble them back</span>
    <span class="c1">// into a tree again:</span>
    <span class="k">case</span> <span class="kd">let</span> <span class="o">.</span><span class="nf">node</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="nv">left</span><span class="p">:</span> <span class="n">leftTree</span><span class="p">,</span> <span class="nv">right</span><span class="p">:</span> <span class="n">rightTree</span><span class="p">):</span>
        <span class="k">return</span> <span class="kt">State</span><span class="o">.</span><span class="nf">zip</span><span class="p">(</span>
            <span class="nf">process</span><span class="p">(</span><span class="nv">value</span><span class="p">:</span> <span class="n">value</span><span class="p">),</span>
            <span class="nf">number_v2</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">leftTree</span><span class="p">),</span>
            <span class="nf">number_v2</span><span class="p">(</span><span class="nv">tree</span><span class="p">:</span> <span class="n">rightTree</span><span class="p">))</span><span class="o">.</span><span class="nf">map</span><span class="p">(</span><span class="kt">Tree</span><span class="o">.</span><span class="n">node</span><span class="p">)</span><span class="o">^</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

    </div>
</div>

</div>
<!-- Custom scripts for this template -->
<script src="/next/js/docs.js"></script>
<!-- Gitter -->
<script>
  ((window.gitter = {}).chat = {}).options = {
    room: 'bowswift/bow'
  };
</script>
<script src="https://sidecar.gitter.im/dist/sidecar.v1.js" async defer></script>

</body>
</html>
